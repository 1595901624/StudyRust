fn main() {
    // 1. 类型转换
    println!("\n****************1. 类型转换***************");
    let o = 5;
    let p = 3.5;

    // 下面是错误写法
    // dbg!(o + p);

    println!("\n****************2. 类型转换表达式***************");

    let q = o as f64;
    dbg!(q);

    println!("\n****************3. 旧题重解***************");
    // 先将 o 转为 f64类型，再做加法
    dbg!(o as f64 + p);

    println!("\n****************4. 类型转换规则(1-有无符号数转换)***************");
    let a: i8 = 1;
    let b: i8 = -1;
    println!("[有符号数] {} 转为[无符号数]: {}, 转换后的二进制为 {:08b}", a, a as u8, a as u8);
    println!("[有符号数] {} 转为[无符号数]: {}, 转换后的二进制为 {:08b}", b, b as u8, b as u8);

    let a: u8 = 1;
    let b: u8 = 255;
    println!("[无符号数] {} 转为[有符号数]: {}, 转换后的二进制为 {:08b}", a, a as i8, a as i8);
    println!("[无符号数] {} 转为[有符号数]: {}, 转换后的二进制为 {:08b}", b, b as i8, b as i8);

    println!("\n****************4. 类型转换规则(2-长转短 截断)***************");
    let a: i16 = 300;
    println!("{} 的 二进制为：{:016b}", a, a);
    // 发生数据截断，保留了低位，截断了高位
    println!("16位整数 {} 转为 8位整数：{}，其二进制为： {:016b}", a, a as i8, a as i8);

    println!("\n****************4. 类型转换规则(3-短转长)***************");
    let a: u8 = 45;
    // a 是8位整数，但是输出时的格式我加了0填充，可以忽略前8位的显示
    println!("8位无符号整数 {} 的 二进制为：{:016b}", a, a);
    println!("8位无符号整数 {} 的 转为16位整数的二进制为：{:016b}", a, a as u16);

    let b: i8 = -121;
    // b 是8位整数，但是输出时的格式我加了0填充，可以忽略前8位的显示
    println!("8位有符号整数 {} 的 二进制为：{:016b}", b, b);
    println!("8位有符号整数 {} 的 转为16位整数的二进制为：{:016b}", a, b as i16);

    println!("\n****************4. 类型转换规则(4-浮点数转整数)***************");
    // NAN 相当于 0.0 / 0.0
    let a: f64 = f64::NAN;
    // 正无穷大 +∞
    let b: f64 = f64::INFINITY;
    // 负无穷大 -∞
    let c: f64 = f64::NEG_INFINITY;

    println!("NAN 转换为整数的值为 {}", a as i32);
    println!("+∞ 转换为整数的值为 {}", b as i32);
    println!("-∞ 转换为整数的值为 {}", c as i32);

    // 其它情况，直接舍弃小数，不会进行四舍五入
    let d: f64 = 54.5;
    let e: f64 = 65.1;

    println!("浮点数 {} 转换为整数 {}", d, d as i32);
    println!("浮点数 {} 转换为整数 {}", e, e as i32);

    println!("\n****************4. 类型转换规则(5-整数转浮点数)***************");
    let a: i32 = 5;
    println!("{} 转为浮点数 {}", a, a as f64);

    // 溢出
    let b: u128 = u128::MAX;
    println!("{} 转为浮点数 {}", b, b as f32);

    println!("\n****************4. 类型转换规则(6-f32浮点数转f64浮点数)***************");
    let a: f32 = 98.0;
    println!("f32浮点数 {} 转为 f64浮点数 {}", a, a as f64);

    println!("\n****************4. 类型转换规则(7-f64浮点数转f32浮点数)***************");
    // 数据浮动，注意精度
    let a: f64 = 9045.213123;
    println!("f64浮点数 {} 转为 f32浮点数 {}", a, a as f32);

    // 溢出
    let b: f64 = f64::MAX;
    println!("f64浮点数 {} 转为 f32浮点数 {}", b, b as f32);

    println!("\n****************4. 类型转换规则(8-布尔型转为整数)***************");
    let a = false;
    let b = true;
    println!("{} 转为 整数为 {}", a, a as i32);
    println!("{} 转为 整数为 {}", b, b as i32);

    println!("\n****************4. 类型转换规则(9-u8转为char)***************");
    // u8转为char
    let a: u8 = 97;
    println!("u8型整数 {} 转为 char 为{}", a, a as char);

    // char转整数
    // 笑脸图标
    let b: char = '\u{1F604}';
    println!("char型 {} 转为i32的值为:{}, 其二进制为 {:032b}", b, b as i32, b as i32);
    println!("char型 {} 转为i16的值为:{}, 其二进制为 {:032b}", b, b as i16, b as i16);
    println!("char型 {} 转为i8的值为:{}, 其二进制为 {:032b}", b, b as i8, b as i8);
}

