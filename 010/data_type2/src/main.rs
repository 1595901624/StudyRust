fn main() {
    println!("\n****************1、数组初始化方式-列举*******************");
    // 未声明类型
    let a = [1, 2, 3, 4, 5];
    // 声明类型
    let b: [i32; 5] = [1, 2, 3, 4, 5];
    dbg!(a);
    dbg!(b);

    println!("\n****************2、数组初始化方式-默认初值相同*******************");
    // 未声明类型
    let c = [2; 5];
    // 声明类型
    let d: [i32; 5] = [2; 5];

    dbg!(c);
    dbg!(d);

    println!("\n****************3、数组访问*******************");
    let e = [2, 4, 6, 8, 10];
    println!("数组e第三个位置的元素是 {}", e[2]);

    println!("\n****************4、数组越界*******************");
    let f = [1, 3, 5, 7, 9];
    println!("f数组的长度是 {}", f.len());
    // 下面的代码会发生数据越界
    // println!("{}", f[5]);

    println!("\n****************5、元组*******************");
    // 1. 声明
    let tup: (i32, f64, bool) = (20, 3.14, false);

    // 一个元素的元组
    let tup_single: (i32, ) = (5, );
    // 下面两种方式不是一个元组
    // 他们等价于 let tup_wrong = 5;
    // let tup_wrong = (5);
    // let tup_wrong: (i32) = (5);
    dbg!(tup_single);

    // 空元组
    let empty_tup = ();
    dbg!(empty_tup);

    // 2. 访问
    println!("{} {} {} ", tup.0, tup.1, tup.2);

    // 3.解构
    let (x, y, z) = tup;
    println!("x: {}, y: {}, z: {}", x, y, z);
}